<?php
/**
 * WordPress to WigglePuppy Rebranding Inventory Generator
 *
 * This script analyzes the codebase to create a comprehensive inventory of
 * "WordPress" instances that need to be rebranded to "WigglePuppy", following
 * the caveats specified in the rebranding plan.
 *
 * _This document was generated by JetBrains Junie_
 */

// Configuration
$extensions = ['php', 'js', 'html', 'css', 'txt', 'md', 'xml', 'json'];
$rootDir = dirname(dirname(__DIR__));
$outputDir = $rootDir . '/docs/rebranding';

// Create output directory if it doesn't exist
if (!mkdir($outputDir, 0755, true) && !is_dir($outputDir)) {
    die("Failed to create output directory: $outputDir\n");
}

// Initialize result arrays
$allFiles = [];
$copyrightInstances = [];
$variableInstances = [];
$functionInstances = [];
$filenameInstances = [];
$urlInstances = [];
$organizationInstances = [];
$visualAssets = [];
$changeableInstances = [];
$coOccurrenceInstances = [];

// Regular expressions for categorization
$copyrightRegex = '/copyright.*wordpress|author.*wordpress/i';
$variableRegex = '/\$[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*/i';
$functionRegex = '/function\s+[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*|[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*\s*\(/i';
$filenameRegex = '/[\'"][a-zA-Z0-9_\/\.\-]*wordpress[a-zA-Z0-9_\/\.\-]*[\'"]/i';
$urlRegex = '/https?:\/\/[a-zA-Z0-9_\.\-]*wordpress[a-zA-Z0-9_\.\-]*/i';
$organizationRegex = '/wordpress\s+team|wordpress\s+foundation|wordpress\s+community|by\s+wordpress/i';
$visualAssetRegex = '/wordpress[\-_]logo|wp[\-_]logo/i';
$coOccurrenceRegex = '/.*wordpress.*wigglepuppy.*|.*wigglepuppy.*wordpress.*/i';

// Function to parse an ignore file and get patterns to exclude
function parseIgnoreFile($filePath) {
    if (!file_exists($filePath)) {
        return [];
    }

    $patterns = [];
    $lines = file($filePath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);

    foreach ($lines as $line) {
        // Skip comments and empty lines
        if (empty($line) || $line[0] === '#') {
            continue;
        }

        // Handle negated patterns (those starting with !)
        $isNegated = false;
        if ($line[0] === '!') {
            $isNegated = true;
            $line = substr($line, 1);
        }

        // Convert pattern to regex pattern
        $pattern = preg_quote($line, '/');
        $pattern = str_replace('\*', '.*', $pattern);

        // Handle directory patterns (those ending with /)
        if (substr($pattern, -1) === '/') {
            $pattern = $pattern . '.*';
        }

        // Add pattern to list
        $patterns[] = [
            'pattern' => '/^' . $pattern . '/',
            'negated' => $isNegated
        ];
    }

    return $patterns;
}

// Function to parse .gitignore file and get patterns to exclude
function parseGitignore($rootDir) {
    $gitignorePath = $rootDir . '/.gitignore';
    return parseIgnoreFile($gitignorePath);
}

// Function to parse rebrand-ignore.txt file and get patterns to exclude
function parseRebrandIgnore($rootDir) {
    $rebrandIgnorePath = $rootDir . '/tools/rebranding/rebrand-ignore.txt';
    return parseIgnoreFile($rebrandIgnorePath);
}

// Function to check if a file should be excluded based on .gitignore and rebrand-ignore.txt patterns
function shouldExcludeFile($filePath, $gitignorePatterns, $rebrandIgnorePatterns, $rootDir) {
    // Get relative path from root directory
    $relativePath = str_replace($rootDir . '/', '', $filePath);

    // Check if file matches any .gitignore pattern
    $excluded = false;
    foreach ($gitignorePatterns as $pattern) {
        if (preg_match($pattern['pattern'], $relativePath)) {
            $excluded = $pattern['negated'] ? false : true;
        }
    }

    // If not excluded by gitignore, check rebrand-ignore.txt patterns
    if (!$excluded) {
        foreach ($rebrandIgnorePatterns as $pattern) {
            if (preg_match($pattern['pattern'], $relativePath)) {
                $excluded = $pattern['negated'] ? false : true;
            }
        }
    }

    return $excluded;
}

// Function to scan directory using a non-recursive approach
function scanDirectory($dir, $extensions, $gitignorePatterns, $rebrandIgnorePatterns, $rootDir) {
    $results = [];
    $stack = [$dir];

    while (!empty($stack)) {
        $currentDir = array_pop($stack);
        $files = scandir($currentDir);

        foreach ($files as $file) {
            if ($file === '.' || $file === '..' || $file === '.git') {
                continue;
            }

            $path = $currentDir . '/' . $file;

            // Skip files/directories that match .gitignore or rebrand-ignore.txt patterns
            if (shouldExcludeFile($path, $gitignorePatterns, $rebrandIgnorePatterns, $rootDir)) {
                continue;
            }

            if (is_dir($path)) {
                // Add directory to stack for later processing
                $stack[] = $path;
            } else {
                $ext = pathinfo($path, PATHINFO_EXTENSION);
                if (in_array($ext, $extensions)) {
                    $results[] = $path;
                }
            }
        }
    }

    return $results;
}

// Function to categorize WordPress instances in a file
function categorizeWordPressInstances($filePath, &$results) {
    global $copyrightRegex, $variableRegex, $functionRegex, $filenameRegex,
           $urlRegex, $organizationRegex, $visualAssetRegex, $coOccurrenceRegex;

    $content = file_get_contents($filePath);

    // Skip if file doesn't contain "wordpress" (case-insensitive)
    if (stripos($content, 'wordpress') === false) {
        return;
    }

    $results['allFiles'][] = $filePath;

    // Process file line by line
    $lines = explode("\n", $content);
    foreach ($lines as $lineNum => $line) {
        // Skip empty lines
        if (trim($line) === '') {
            continue;
        }

        // Check for co-occurrence first (these lines should remain unchanged)
        if (preg_match($coOccurrenceRegex, $line)) {
            $results['coOccurrenceInstances'][] = [
                'file' => $filePath,
                'line' => $lineNum + 1,
                'content' => $line
            ];
            continue;
        }

        // Check for copyright notices and author attributions
        if (preg_match($copyrightRegex, $line)) {
            $results['copyrightInstances'][] = [
                'file' => $filePath,
                'line' => $lineNum + 1,
                'content' => $line
            ];
            continue;
        }

        // Check for variable names
        if (preg_match($variableRegex, $line)) {
            $results['variableInstances'][] = [
                'file' => $filePath,
                'line' => $lineNum + 1,
                'content' => $line
            ];
            continue;
        }

        // Check for function names
        if (preg_match($functionRegex, $line)) {
            $results['functionInstances'][] = [
                'file' => $filePath,
                'line' => $lineNum + 1,
                'content' => $line
            ];
            continue;
        }

        // Check for filenames and paths
        if (preg_match($filenameRegex, $line)) {
            $results['filenameInstances'][] = [
                'file' => $filePath,
                'line' => $lineNum + 1,
                'content' => $line
            ];
            continue;
        }

        // Check for URLs
        if (preg_match($urlRegex, $line)) {
            $results['urlInstances'][] = [
                'file' => $filePath,
                'line' => $lineNum + 1,
                'content' => $line
            ];
            continue;
        }

        // Check for organization references
        if (preg_match($organizationRegex, $line)) {
            $results['organizationInstances'][] = [
                'file' => $filePath,
                'line' => $lineNum + 1,
                'content' => $line
            ];
            continue;
        }

        // Check for visual assets
        if (preg_match($visualAssetRegex, $line)) {
            $results['visualAssets'][] = [
                'file' => $filePath,
                'line' => $lineNum + 1,
                'content' => $line
            ];
            continue;
        }

        // If the line contains "wordpress" but doesn't match any of the above categories,
        // it's likely a changeable instance
        if (stripos($line, 'wordpress') !== false) {
            $results['changeableInstances'][] = [
                'file' => $filePath,
                'line' => $lineNum + 1,
                'content' => $line
            ];
        }
    }
}

// Function to write results to files
function writeResultsToFiles($results, $outputDir) {
    // Write summary file
    $summaryFile = $outputDir . '/rebranding-summary.md';
    $summary = "# WordPress to WigglePuppy Rebranding Inventory\n";
    $summary .= "_This document was generated by JetBrains Junie_\n\n";
    $summary .= "## Summary\n\n";
    $summary .= "- Total files containing 'WordPress': " . count($results['allFiles']) . "\n";
    $summary .= "- Copyright/Author instances (do not change): " . count($results['copyrightInstances']) . "\n";
    $summary .= "- Variable name instances (do not change): " . count($results['variableInstances']) . "\n";
    $summary .= "- Function name instances (do not change): " . count($results['functionInstances']) . "\n";
    $summary .= "- Filename/path instances (do not change): " . count($results['filenameInstances']) . "\n";
    $summary .= "- URL instances (do not change): " . count($results['urlInstances']) . "\n";
    $summary .= "- Organization reference instances (do not change): " . count($results['organizationInstances']) . "\n";
    $summary .= "- Visual asset instances: " . count($results['visualAssets']) . "\n";
    $summary .= "- Co-occurrence instances (do not change): " . count($results['coOccurrenceInstances']) . "\n";
    $summary .= "- Changeable instances: " . count($results['changeableInstances']) . "\n\n";

    $summary .= "## Replacement Strategy\n\n";
    $summary .= "### Instances to Change\n\n";
    $summary .= "The following instances should be changed from 'WordPress' to 'WigglePuppy' (preserving case):\n\n";
    $summary .= "- All instances categorized as 'changeable' in the detailed reports\n\n";

    $summary .= "### Instances to Preserve\n\n";
    $summary .= "The following instances should NOT be changed:\n\n";
    $summary .= "1. Copyright notices and author attributions\n";
    $summary .= "2. Variable names containing 'wordpress'\n";
    $summary .= "3. Function names containing 'wordpress'\n";
    $summary .= "4. Filenames and paths containing 'wordpress'\n";
    $summary .= "5. URLs containing 'wordpress'\n";
    $summary .= "6. References to WordPress as an organization\n";
    $summary .= "7. Lines containing both 'wordpress' and 'wigglepuppy'\n\n";

    $summary .= "### Implementation Approach\n\n";
    $summary .= "1. **Rector Rules**: For PHP files, custom Rector rules can be developed to handle the replacement of 'WordPress' with 'WigglePuppy' in string literals and comments, while respecting the caveats.\n\n";
    $summary .= "2. **Regex Search/Replace**: For non-PHP files (JS, HTML, CSS, etc.), regex-based search and replace scripts can be used.\n\n";
    $summary .= "3. **Visual Assets**: Visual assets will require manual replacement with new WigglePuppy designs.\n\n";

    file_put_contents($summaryFile, $summary);

    // Write detailed reports for each category
    $categories = [
        'allFiles' => 'All Files Containing WordPress',
        'copyrightInstances' => 'Copyright and Author Attributions (Do Not Change)',
        'variableInstances' => 'Variable Names (Do Not Change)',
        'functionInstances' => 'Function Names (Do Not Change)',
        'filenameInstances' => 'Filenames and Paths (Do Not Change)',
        'urlInstances' => 'URLs (Do Not Change)',
        'organizationInstances' => 'Organization References (Do Not Change)',
        'visualAssets' => 'Visual Assets',
        'coOccurrenceInstances' => 'Co-occurrence of WordPress and WigglePuppy (Do Not Change)',
        'changeableInstances' => 'Changeable Instances'
    ];

    foreach ($categories as $category => $title) {
        if ($category === 'allFiles') {
            $content = "# $title\n";
            $content .= "_This document was generated by JetBrains Junie_\n\n";
            foreach ($results[$category] as $file) {
                $content .= "- $file\n";
            }
        } else {
            $content = "# $title\n";
            $content .= "_This document was generated by JetBrains Junie_\n\n";
            $content .= "| File | Line | Content |\n";
            $content .= "|------|------|--------|\n";
            foreach ($results[$category] as $instance) {
                $escapedContent = str_replace('|', '\\|', $instance['content']);
                $content .= "| {$instance['file']} | {$instance['line']} | `$escapedContent` |\n";
            }
        }

        $filename = $outputDir . '/' . $category . '.md';
        file_put_contents($filename, $content);
    }

    // Create a mapping document
    $mappingContent = "# WordPress to WigglePuppy Mapping Document\n";
    $mappingContent .= "_This document was generated by JetBrains Junie_\n\n";
    $mappingContent .= "## Mapping Rules\n\n";
    $mappingContent .= "When replacing 'WordPress' with 'WigglePuppy', the following casing rules must be observed:\n\n";
    $mappingContent .= "- 'WordPress' → 'WigglePuppy'\n";
    $mappingContent .= "- 'wordpress' → 'wigglepuppy'\n";
    $mappingContent .= "- 'WORDPRESS' → 'WIGGLEPUPPY'\n\n";

    $mappingContent .= "## Replacement Examples\n\n";
    $mappingContent .= "| Original | Replacement |\n";
    $mappingContent .= "|----------|-------------|\n";
    $mappingContent .= "| 'Welcome to WordPress' | 'Welcome to WigglePuppy' |\n";
    $mappingContent .= "| 'wordpress_option' | 'wordpress_option' (do not change - variable name) |\n";
    $mappingContent .= "| 'WORDPRESS_DEBUG' | 'WIGGLEPUPPY_DEBUG' |\n";
    $mappingContent .= "| 'wordpress.org' | 'wordpress.org' (do not change - URL) |\n";
    $mappingContent .= "| 'WordPress team' | 'WordPress team' (do not change - organization reference) |\n";
    $mappingContent .= "| 'Copyright © WordPress' | 'Copyright © WordPress' (do not change - copyright notice) |\n";

    $mappingFile = $outputDir . '/mapping-document.md';
    file_put_contents($mappingFile, $mappingContent);

    // Create a Rector configuration suggestion
    $rectorContent = "# Rector Configuration for WordPress to WigglePuppy Rebranding\n";
    $rectorContent .= "_This document was generated by JetBrains Junie_\n\n";
    $rectorContent .= "## Custom Rector Rules\n\n";
    $rectorContent .= "The following custom Rector rules should be developed for the rebranding process:\n\n";
    $rectorContent .= "1. **WordPressToWigglePuppyStringRector**: Replaces 'WordPress' with 'WigglePuppy' in string literals, preserving case.\n";
    $rectorContent .= "2. **WordPressToWigglePuppyCommentRector**: Replaces 'WordPress' with 'WigglePuppy' in comments, preserving case.\n\n";

    $rectorContent .= "## Implementation Example\n\n";
    $rectorContent .= "```php\n";
    $rectorContent .= "namespace WigglePuppy\\Rector\\Rebranding;\n\n";
    $rectorContent .= "use PhpParser\\Node;\n";
    $rectorContent .= "use PhpParser\\Node\\Scalar\\String_;\n";
    $rectorContent .= "use Rector\\Core\\Rector\\AbstractRector;\n";
    $rectorContent .= "use Symplify\\RuleDocGenerator\\ValueObject\\RuleDefinition;\n\n";
    $rectorContent .= "final class WordPressToWigglePuppyStringRector extends AbstractRector\n";
    $rectorContent .= "{\n";
    $rectorContent .= "    public function getRuleDefinition(): RuleDefinition\n";
    $rectorContent .= "    {\n";
    $rectorContent .= "        // Rule documentation\n";
    $rectorContent .= "    }\n\n";
    $rectorContent .= "    public function getNodeTypes(): array\n";
    $rectorContent .= "    {\n";
    $rectorContent .= "        return [String_::class];\n";
    $rectorContent .= "    }\n\n";
    $rectorContent .= "    public function refactor(Node \$node): ?Node\n";
    $rectorContent .= "    {\n";
    $rectorContent .= "        if (!\$node instanceof String_) {\n";
    $rectorContent .= "            return null;\n";
    $rectorContent .= "        }\n\n";
    $rectorContent .= "        \$content = \$node->value;\n\n";
    $rectorContent .= "        // Skip if the string contains patterns we shouldn't replace\n";
    $rectorContent .= "        if (preg_match('/wordpress\\.org|wordpress\\.com|function.*wordpress|class.*wordpress|\\$.*wordpress/i', \$content)) {\n";
    $rectorContent .= "            return null;\n";
    $rectorContent .= "        }\n\n";
    $rectorContent .= "        // Replace WordPress with WigglePuppy preserving case\n";
    $rectorContent .= "        \$newContent = preg_replace('/\\bWordPress\\b/', 'WigglePuppy', \$content);\n";
    $rectorContent .= "        \$newContent = preg_replace('/\\bwordpress\\b/', 'wigglepuppy', \$newContent);\n";
    $rectorContent .= "        \$newContent = preg_replace('/\\bWORDPRESS\\b/', 'WIGGLEPUPPY', \$newContent);\n\n";
    $rectorContent .= "        if (\$newContent === \$content) {\n";
    $rectorContent .= "            return null;\n";
    $rectorContent .= "        }\n\n";
    $rectorContent .= "        \$node->value = \$newContent;\n";
    $rectorContent .= "        return \$node;\n";
    $rectorContent .= "    }\n";
    $rectorContent .= "}\n";
    $rectorContent .= "```\n\n";

    $rectorContent .= "## Rector Configuration\n\n";
    $rectorContent .= "```php\n";
    $rectorContent .= "// rector.php\n";
    $rectorContent .= "use Rector\\Config\\RectorConfig;\n";
    $rectorContent .= "use WigglePuppy\\Rector\\Rebranding\\WordPressToWigglePuppyStringRector;\n";
    $rectorContent .= "use WigglePuppy\\Rector\\Rebranding\\WordPressToWigglePuppyCommentRector;\n\n";
    $rectorContent .= "return static function (RectorConfig \$rectorConfig): void {\n";
    $rectorContent .= "    \$rectorConfig->paths([\n";
    $rectorContent .= "        __DIR__ . '/src',\n";
    $rectorContent .= "    ]);\n\n";
    $rectorContent .= "    \$rectorConfig->rule(WordPressToWigglePuppyStringRector::class);\n";
    $rectorContent .= "    \$rectorConfig->rule(WordPressToWigglePuppyCommentRector::class);\n";
    $rectorContent .= "};\n";
    $rectorContent .= "```\n";

    $rectorFile = $outputDir . '/rector-configuration.md';
    file_put_contents($rectorFile, $rectorContent);
}

// Main execution
echo "Starting WordPress to WigglePuppy rebranding inventory generation...\n";

// Parse .gitignore file
echo "Parsing .gitignore file...\n";
$gitignorePatterns = parseGitignore($rootDir);

// Parse rebrand-ignore.txt file
echo "Parsing rebrand-ignore.txt file...\n";
$rebrandIgnorePatterns = parseRebrandIgnore($rootDir);

// Scan all files with specified extensions
echo "Scanning files...\n";
$files = scanDirectory($rootDir, $extensions, $gitignorePatterns, $rebrandIgnorePatterns, $rootDir);
echo "Found " . count($files) . " files with specified extensions.\n";

// Initialize results array
$results = [
    'allFiles' => [],
    'copyrightInstances' => [],
    'variableInstances' => [],
    'functionInstances' => [],
    'filenameInstances' => [],
    'urlInstances' => [],
    'organizationInstances' => [],
    'visualAssets' => [],
    'changeableInstances' => [],
    'coOccurrenceInstances' => []
];

// Process each file
$processedFiles = 0;
$totalFiles = count($files);
foreach ($files as $file) {
    categorizeWordPressInstances($file, $results);
    $processedFiles++;
    if ($processedFiles % 100 === 0 || $processedFiles === $totalFiles) {
        echo "Processed $processedFiles/$totalFiles files...\n";
    }
}

// Write results to files
echo "Writing results to $outputDir...\n";
writeResultsToFiles($results, $outputDir);

echo "Rebranding inventory generation complete!\n";
echo "Summary report: $outputDir/rebranding-summary.md\n";
