<?php
/**
 * WordPress to WigglePuppy Batch Rebranding Script
 *
 * This script performs all non-rector regex replacements in a single batch,
 * respecting all the requirements in rebranding.md. It generates a manifest
 * file of all changes made.
 *
 * _This document was generated by JetBrains Junie_
 */

// Configuration
$rootDir = dirname(dirname(__DIR__));
$outputDir = $rootDir . '/docs/rebranding';
$manifestFile = $outputDir . '/rebranding-manifest.json';
$logFile = $outputDir . '/batch-rebranding-log.md';

// Create output directory if it doesn't exist
if (!is_dir($outputDir) && !mkdir($outputDir, 0755, true) && !is_dir($outputDir)) {
    throw new \RuntimeException(sprintf('Directory "%s" was not created', $outputDir));
}

// File extensions to process
$extensions = [
    // Text files
    'txt', 'md', 'html', 'htm', 'xml', 'csv', 'json', 'svg',

    // Web files
    'php', 'js', 'css', 'scss', 'less',

    // Config files
    'yml', 'yaml', 'ini', 'config',

    // Other
    'sql', 'sh', 'bat'
];

// Regular expressions for identifying patterns that should not be replaced
$skipPatterns = [
    // Copyright notices and author attributions
    '/copyright.*wordpress|author.*wordpress/i',

    // PHP Identifiers
    '/\$[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*/i', // Variables
    '/function\s+[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*|[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*\s*\(/i', // Functions
    '/class\s+[a-zA-Z0-9_]*WordPress[a-zA-Z0-9_]*/i', // Classes
    '/namespace\s+[a-zA-Z0-9_\\\\]*WordPress[a-zA-Z0-9_\\\\]*/i', // Namespaces
    '/const\s+[a-zA-Z0-9_]*WORDPRESS[a-zA-Z0-9_]*/i', // Constants

    // Filenames and URLs
    '/[\'"][a-zA-Z0-9_\/\.\-]*wordpress[a-zA-Z0-9_\/\.\-]*[\'"]/i', // Filenames
    '/https?:\/\/[a-zA-Z0-9_\.\-]*wordpress[a-zA-Z0-9_\.\-]*/i', // URLs
    '/[\'"]\/wp-[a-zA-Z0-9_\/\.\-]*[\'"]/i', // WordPress paths

    // WordPress as an Organization
    '/wordpress\s+team|wordpress\s+foundation|wordpress\s+community|by\s+wordpress/i',
    '/visit\s+wordpress\.org|wordpress\.org\s+for/i',

    // JavaScript Identifiers
    '/\b[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*\b\s*[:=]/i', // JS variables
    '/\b[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*\b\s*\(/i', // JS functions
    '/@wordpress\/[a-zA-Z0-9_\-]*/i', // npm namespaces

    // Co-occurrence of WordPress and WigglePuppy
    '/.*wordpress.*wigglepuppy.*|.*wigglepuppy.*wordpress.*/i'
];

// Replacement patterns (preserving case)
$replacementPatterns = [
    '/\bWordPress\b/' => 'WigglePuppy',
    '/\bwordpress\b/' => 'wigglepuppy',
    '/\bWORDPRESS\b/' => 'WIGGLEPUPPY'
];

// Function to parse .gitignore file and get patterns to exclude
function parseGitignore($rootDir) {
    $gitignorePath = $rootDir . '/.gitignore';
    if (!file_exists($gitignorePath)) {
        return [];
    }

    $patterns = [];
    $lines = file($gitignorePath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);

    foreach ($lines as $line) {
        // Skip comments and empty lines
        if (empty($line) || $line[0] === '#') {
            continue;
        }

        // Handle negated patterns (those starting with !)
        $isNegated = false;
        if ($line[0] === '!') {
            $isNegated = true;
            $line = substr($line, 1);
        }

        // Convert .gitignore pattern to regex pattern
        $pattern = preg_quote($line, '/');
        $pattern = str_replace('\*', '.*', $pattern);

        // Handle directory patterns (those ending with /)
        if (substr($pattern, -1) === '/') {
            $pattern = $pattern . '.*';
        }

        // Add pattern to list
        $patterns[] = [
            'pattern' => '/^' . $pattern . '/',
            'negated' => $isNegated
        ];
    }

    return $patterns;
}

// Function to check if a file should be excluded based on .gitignore patterns
function shouldExcludeFile($filePath, $gitignorePatterns, $rootDir) {
    // Get relative path from root directory
    $relativePath = str_replace($rootDir . '/', '', $filePath);

    // Check if file matches any .gitignore pattern
    $excluded = false;
    foreach ($gitignorePatterns as $pattern) {
        if (preg_match($pattern['pattern'], $relativePath)) {
            $excluded = $pattern['negated'] ? false : true;
        }
    }

    return $excluded;
}

// Function to check if a file is minified
function isMinifiedFile($filePath) {
    // Check file extension for .min.js or .min.css
    if (preg_match('/\.min\.(js|css)$/', $filePath)) {
        return true;
    }

    // Check file content for minification characteristics
    $content = file_get_contents($filePath);
    $fileSize = strlen($content);
    $lineCount = substr_count($content, "\n") + 1;

    // Heuristic: If average line length is very high, it's likely minified
    $avgLineLength = $fileSize / $lineCount;
    if ($avgLineLength > 500) {
        return true;
    }

    return false;
}

// Function to scan directory recursively
function scanDirectory($dir, $extensions, $gitignorePatterns, $rootDir) {
    $results = [];
    $stack = [$dir];

    while (!empty($stack)) {
        $currentDir = array_pop($stack);
        $files = scandir($currentDir);

        foreach ($files as $file) {
            if ($file === '.' || $file === '..' || $file === '.git') {
                continue;
            }

            $path = $currentDir . '/' . $file;

            // Skip files/directories that match .gitignore patterns
            if (shouldExcludeFile($path, $gitignorePatterns, $rootDir)) {
                continue;
            }

            if (is_dir($path)) {
                // Add directory to stack for later processing
                $stack[] = $path;
            } else {
                $ext = pathinfo($path, PATHINFO_EXTENSION);
                if (in_array($ext, $extensions)) {
                    // Skip minified files
                    if (isMinifiedFile($path)) {
                        continue;
                    }
                    $results[] = $path;
                }
            }
        }
    }

    return $results;
}

// Function to check if a line should be skipped
function shouldSkipLine($line, $skipPatterns) {
    foreach ($skipPatterns as $pattern) {
        if (preg_match($pattern, $line)) {
            return true;
        }
    }
    return false;
}

// Function to replace WordPress with WigglePuppy in a line
function replaceWordPress($line, $replacementPatterns) {
    $newLine = $line;
    foreach ($replacementPatterns as $pattern => $replacement) {
        $newLine = preg_replace($pattern, $replacement, $newLine);
    }
    return $newLine;
}

// Function to process a file
function processFile($filePath, $skipPatterns, $replacementPatterns, &$log, &$manifest) {
    // Read the file content preserving the original line endings
    $content = file_get_contents($filePath);

    // Detect line endings (CR, LF, or CRLF)
    $lineEnding = "\n"; // Default to LF
    if (strpos($content, "\r\n") !== false) {
        $lineEnding = "\r\n"; // CRLF (Windows)
    } elseif (strpos($content, "\r") !== false) {
        $lineEnding = "\r"; // CR (old Mac)
    }

    $lines = explode($lineEnding, $content);
    $modified = false;
    $replacements = 0;
    $fileManifest = [];

    foreach ($lines as $i => $line) {
        // Skip empty lines
        if (trim($line) === '') {
            continue;
        }

        // Skip lines that match skip patterns
        if (shouldSkipLine($line, $skipPatterns)) {
            continue;
        }

        // Replace WordPress with WigglePuppy while preserving whitespace
        $newLine = replaceWordPress($line, $replacementPatterns);

        // If the line was changed, update it
        if ($newLine !== $line) {
            $lines[$i] = $newLine;
            $modified = true;
            $replacements++;

            // Log the replacement
            $log[] = [
                'file' => $filePath,
                'line' => $i + 1,
                'before' => $line,
                'after' => $newLine
            ];

            // Add to file manifest
            $fileManifest[] = [
                'line' => $i + 1,
                'before' => $line,
                'after' => $newLine
            ];
        }
    }

    // If the file was modified, write the changes back preserving original line endings
    if ($modified) {
        file_put_contents($filePath, implode($lineEnding, $lines));

        // Add to manifest
        $manifest[$filePath] = [
            'replacements' => $replacements,
            'changes' => $fileManifest
        ];

        return $replacements;
    }

    return 0;
}

// Function to write log to file
function writeLog($log, $logFile) {
    $content = "# WordPress to WigglePuppy Batch Rebranding Log\n";
    $content .= "_This document was generated by JetBrains Junie_\n\n";
    $content .= "## Summary\n\n";
    $content .= "- Total files processed: " . count($log['files']) . "\n";
    $content .= "- Total replacements made: " . $log['totalReplacements'] . "\n\n";

    $content .= "## Replacements\n\n";
    $content .= "| File | Line | Before | After |\n";
    $content .= "|------|------|--------|-------|\n";

    foreach ($log['replacements'] as $replacement) {
        $escapedBefore = str_replace('|', '\\|', $replacement['before']);
        $escapedAfter = str_replace('|', '\\|', $replacement['after']);
        $content .= "| {$replacement['file']} | {$replacement['line']} | `$escapedBefore` | `$escapedAfter` |\n";
    }

    file_put_contents($logFile, $content);
}

// Function to write manifest to file
function writeManifest($manifest, $manifestFile) {
    file_put_contents($manifestFile, json_encode($manifest, JSON_PRETTY_PRINT));
}

// Main execution
echo "Starting WordPress to WigglePuppy batch rebranding...\n";

// Parse .gitignore file
echo "Parsing .gitignore file...\n";
$gitignorePatterns = parseGitignore($rootDir);

// Scan all files with specified extensions
echo "Scanning files...\n";
$files = scanDirectory($rootDir, $extensions, $gitignorePatterns, $rootDir);
echo "Found " . count($files) . " files to process.\n";

// Initialize log and manifest
$log = [
    'files' => [],
    'replacements' => [],
    'totalReplacements' => 0
];
$manifest = [];

// Process each file
$processedFiles = 0;
$totalFiles = count($files);
foreach ($files as $file) {
    $replacements = processFile($file, $skipPatterns, $replacementPatterns, $log['replacements'], $manifest);

    if ($replacements > 0) {
        $log['files'][] = $file;
        $log['totalReplacements'] += $replacements;
    }

    $processedFiles++;
    if ($processedFiles % 100 === 0 || $processedFiles === $totalFiles) {
        echo "Processed $processedFiles/$totalFiles files...\n";
    }
}

// Write log and manifest to files
echo "Writing log to $logFile...\n";
writeLog($log, $logFile);

echo "Writing manifest to $manifestFile...\n";
writeManifest($manifest, $manifestFile);

echo "Batch rebranding complete!\n";
echo "Total files modified: " . count($log['files']) . "\n";
echo "Total replacements made: " . $log['totalReplacements'] . "\n";
echo "Log file: $logFile\n";
echo "Manifest file: $manifestFile\n";
