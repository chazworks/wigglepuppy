<?php
/**
 * WordPress to WigglePuppy Batch Rebranding Script
 *
 * This script performs all non-rector regex replacements in a single batch,
 * respecting all the requirements in rebranding.md. It generates a manifest
 * file of all changes made.
 *
 * _This document was generated by JetBrains Junie_
 */

// Configuration
$rootDir = dirname(dirname(__DIR__));
$outputDir = $rootDir . '/docs/rebranding';
$manifestFile = $outputDir . '/rebranding-manifest.json';
$logFile = $outputDir . '/batch-rebranding-log.md';

// Parse command line options
$options = getopt("m:h", ["max:", "help"]);

// Display help if requested
if (isset($options['h']) || isset($options['help'])) {
    echo "Usage: php batch-rebranding.php [options]\n";
    echo "Options:\n";
    echo "  -m, --max <number>    Maximum number of files to process (default: no limit)\n";
    echo "  -h, --help            Display this help message\n";
    exit(0);
}

// Get maximum files to process from command line option
$maxFilesToProcess = null; // Default: no limit
if (isset($options['m'])) {
    $maxFilesToProcess = (int)$options['m'];
} elseif (isset($options['max'])) {
    $maxFilesToProcess = (int)$options['max'];
}

// Create output directory if it doesn't exist
if (!is_dir($outputDir) && !mkdir($outputDir, 0755, true) && !is_dir($outputDir)) {
    throw new \RuntimeException(sprintf('Directory "%s" was not created', $outputDir));
}

// File extensions to process
$extensions = [
    // Text files
    'txt', 'md', 'html', 'htm', 'xml', 'csv', 'json', 'svg',

    // Web files
    'php', 'js', 'css', 'scss', 'less',

    // Config files
    'yml', 'yaml', 'ini', 'config',

    // Other
    'sql', 'sh', 'bat'
];

// Regular expressions for identifying patterns that should not be replaced
$skipPatterns = [
    // Copyright notices and author attributions
    '/copyright.*wordpress|author.*wordpress/i',

    // PHP Identifiers
    '/\$[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*/i', // Variables
    '/function\s+[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*|[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*\s*\(/i', // Functions
    '/class\s+[a-zA-Z0-9_]*WordPress[a-zA-Z0-9_]*/i', // Classes
    '/namespace\s+[a-zA-Z0-9_\\\\]*WordPress[a-zA-Z0-9_\\\\]*/i', // Namespaces
    '/const\s+[a-zA-Z0-9_]*WORDPRESS[a-zA-Z0-9_]*/i', // Constants

    // Filenames and URLs
    '/[\'"][a-zA-Z0-9_\/\.\-]*wordpress[a-zA-Z0-9_\/\.\-]*[\'"]/i', // Filenames
    '/https?:\/\/[a-zA-Z0-9_\.\-]*wordpress[a-zA-Z0-9_\.\-]*/i', // URLs
    '/[\'"]\/wp-[a-zA-Z0-9_\/\.\-]*[\'"]/i', // WordPress paths

    // WordPress as an Organization
    '/wordpress\s+team|wordpress\s+foundation|wordpress\s+community|by\s+wordpress/i',
    '/visit\s+wordpress\.org|wordpress\.org\s+for/i',

    // JavaScript Identifiers
    '/\b[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*\b\s*[:=]/i', // JS variables
    '/\b[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*\b\s*\(/i', // JS functions
    '/@wordpress\/[a-zA-Z0-9_\-]*/i', // npm namespaces

    // Co-occurrence of WordPress and WigglePuppy
    '/.*wordpress.*wigglepuppy.*|.*wigglepuppy.*wordpress.*/i'
];

// Replacement patterns (preserving case)
$replacementPatterns = [
    '/\bWordPress\b/' => 'WigglePuppy',
    '/\bwordpress\b/' => 'wigglepuppy',
    '/\bWORDPRESS\b/' => 'WIGGLEPUPPY'
];

// Function to parse an ignore file and get patterns to exclude
function parseIgnoreFile($filePath) {
    if (!file_exists($filePath)) {
        return [];
    }

    $patterns = [];
    $lines = file($filePath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);

    foreach ($lines as $line) {
        // Skip comments and empty lines
        if (empty($line) || $line[0] === '#') {
            continue;
        }

        // Handle negated patterns (those starting with !)
        $isNegated = false;
        if ($line[0] === '!') {
            $isNegated = true;
            $line = substr($line, 1);
        }

        // Convert pattern to regex pattern
        $pattern = preg_quote($line, '/');
        $pattern = str_replace('\*', '.*', $pattern);

        // Handle directory patterns (those ending with /)
        if (substr($pattern, -1) === '/') {
            $pattern = $pattern . '.*';
        }

        // Add pattern to list
        $patterns[] = [
            'pattern' => '/^' . $pattern . '/',
            'negated' => $isNegated
        ];
    }

    return $patterns;
}

// Function to parse .gitignore file and get patterns to exclude
function parseGitignore($rootDir) {
    $gitignorePath = $rootDir . '/.gitignore';
    return parseIgnoreFile($gitignorePath);
}

// Function to parse rebrand-ignore.txt file and get patterns to exclude
function parseRebrandIgnore($rootDir) {
    $rebrandIgnorePath = $rootDir . '/tools/rebranding/rebrand-ignore.txt';
    return parseIgnoreFile($rebrandIgnorePath);
}

// Function to check if a file should be excluded based on .gitignore and rebrand-ignore.txt patterns
function shouldExcludeFile($filePath, $gitignorePatterns, $rebrandIgnorePatterns, $rootDir) {
    // Get relative path from root directory
    $relativePath = str_replace($rootDir . '/', '', $filePath);

    // Check if file matches any .gitignore pattern
    $excluded = false;
    foreach ($gitignorePatterns as $pattern) {
        if (preg_match($pattern['pattern'], $relativePath)) {
            $excluded = $pattern['negated'] ? false : true;
        }
    }

    // If not excluded by gitignore, check rebrand-ignore.txt patterns
    if (!$excluded) {
        foreach ($rebrandIgnorePatterns as $pattern) {
            if (preg_match($pattern['pattern'], $relativePath)) {
                $excluded = $pattern['negated'] ? false : true;
            }
        }
    }

    return $excluded;
}

// Function to check if a file is minified
function isMinifiedFile($filePath) {
    // Check file extension for .min.js or .min.css
    if (preg_match('/\.min\.(js|css)$/', $filePath)) {
        return true;
    }

    // Check file content for minification characteristics
    $content = file_get_contents($filePath);
    $fileSize = strlen($content);
    $lineCount = substr_count($content, "\n") + 1;

    // Heuristic: If average line length is very high, it's likely minified
    $avgLineLength = $fileSize / $lineCount;
    if ($avgLineLength > 500) {
        return true;
    }

    return false;
}

// Function to scan directory recursively
function scanDirectory($dir, $extensions, $gitignorePatterns, $rebrandIgnorePatterns, $rootDir) {
    $results = [];
    $stack = [$dir];

    while (!empty($stack)) {
        $currentDir = array_pop($stack);
        $files = scandir($currentDir);

        foreach ($files as $file) {
            if ($file === '.' || $file === '..' || $file === '.git') {
                continue;
            }

            $path = $currentDir . '/' . $file;

            // Skip files/directories that match .gitignore or rebrand-ignore.txt patterns
            if (shouldExcludeFile($path, $gitignorePatterns, $rebrandIgnorePatterns, $rootDir)) {
                continue;
            }

            if (is_dir($path)) {
                // Add directory to stack for later processing
                $stack[] = $path;
            } else {
                $ext = pathinfo($path, PATHINFO_EXTENSION);
                if (in_array($ext, $extensions)) {
                    // Skip minified files
                    if (isMinifiedFile($path)) {
                        continue;
                    }
                    $results[] = $path;
                }
            }
        }
    }

    return $results;
}

// Function to check if a line should be skipped
function shouldSkipLine($line, $skipPatterns, &$skipReason = null) {
    // Skip empty lines
    if (trim($line) === '') {
        return true;
    }

    // Define skip pattern descriptions for logging
    $patternDescriptions = [
        '/copyright.*wordpress|author.*wordpress/i' => 'Copyright notice or author attribution',
        '/\$[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*/i' => 'PHP variable name',
        '/function\s+[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*|[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*\s*\(/i' => 'PHP function name',
        '/class\s+[a-zA-Z0-9_]*WordPress[a-zA-Z0-9_]*/i' => 'PHP class name',
        '/namespace\s+[a-zA-Z0-9_\\\\]*WordPress[a-zA-Z0-9_\\\\]*/i' => 'PHP namespace',
        '/const\s+[a-zA-Z0-9_]*WORDPRESS[a-zA-Z0-9_]*/i' => 'PHP constant',
        '/[\'"][a-zA-Z0-9_\/\.\-]*wordpress[a-zA-Z0-9_\/\.\-]*[\'"]/i' => 'Filename or path',
        '/https?:\/\/[a-zA-Z0-9_\.\-]*wordpress[a-zA-Z0-9_\.\-]*/i' => 'URL',
        '/[\'"]\/wp-[a-zA-Z0-9_\/\.\-]*[\'"]/i' => 'WordPress path',
        '/wordpress\s+team|wordpress\s+foundation|wordpress\s+community|by\s+wordpress/i' => 'WordPress as organization',
        '/visit\s+wordpress\.org|wordpress\.org\s+for/i' => 'WordPress.org reference',
        '/\b[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*\b\s*[:=]/i' => 'JavaScript variable',
        '/\b[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*\b\s*\(/i' => 'JavaScript function',
        '/@wordpress\/[a-zA-Z0-9_\-]*/i' => 'npm namespace',
        '/.*wordpress.*wigglepuppy.*|.*wigglepuppy.*wordpress.*/i' => 'Co-occurrence of WordPress and WigglePuppy'
    ];

    foreach ($skipPatterns as $pattern) {
        if (preg_match($pattern, $line)) {
            // Set the skip reason if the pattern is in our descriptions
            if (isset($patternDescriptions[$pattern])) {
                $skipReason = $patternDescriptions[$pattern];
            } else {
                $skipReason = 'Matched skip pattern';
            }
            return true;
        }
    }

    // Check for package/module names (additional check not in original skipPatterns)
    if (preg_match('/package\s+[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*/i', $line) ||
        preg_match('/module\s+[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*/i', $line)) {
        $skipReason = 'Package or module name';
        return true;
    }

    return false;
}

// Function to replace WordPress with WigglePuppy in a line
function replaceWordPress($line, $replacementPatterns) {
    $newLine = $line;
    foreach ($replacementPatterns as $pattern => $replacement) {
        $newLine = preg_replace($pattern, $replacement, $newLine);
    }
    return $newLine;
}

// Function to process a file
function processFile($filePath, $skipPatterns, $replacementPatterns, &$log, &$manifest) {
    // Read the file content preserving the original line endings
    $content = file_get_contents($filePath);

    // Detect line endings (CR, LF, or CRLF)
    $lineEnding = "\n"; // Default to LF
    if (strpos($content, "\r\n") !== false) {
        $lineEnding = "\r\n"; // CRLF (Windows)
    } elseif (strpos($content, "\r") !== false) {
        $lineEnding = "\r"; // CR (old Mac)
    }

    $lines = explode($lineEnding, $content);
    $modified = false;
    $replacements = 0;
    $skipped = 0;
    $fileManifest = [
        'replacements' => [],
        'skipped' => []
    ];

    foreach ($lines as $i => $line) {
        // Skip empty lines
        if (trim($line) === '') {
            continue;
        }

        // Check if line contains "WordPress" in any form
        if (preg_match('/wordpress/i', $line)) {
            $skipReason = null;

            // Check if line should be skipped due to caveats
            if (shouldSkipLine($line, $skipPatterns, $skipReason)) {
                $skipped++;

                // Log the skipped line
                $log['skipped'][] = [
                    'file' => $filePath,
                    'line' => $i + 1,
                    'content' => $line,
                    'reason' => $skipReason
                ];

                // Add to file manifest
                $fileManifest['skipped'][] = [
                    'line' => $i + 1,
                    'content' => $line,
                    'reason' => $skipReason
                ];

                continue;
            }

            // Replace WordPress with WigglePuppy while preserving whitespace
            $newLine = replaceWordPress($line, $replacementPatterns);

            // If the line was changed, update it
            if ($newLine !== $line) {
                $lines[$i] = $newLine;
                $modified = true;
                $replacements++;

                // Log the replacement
                $log['replacements'][] = [
                    'file' => $filePath,
                    'line' => $i + 1,
                    'before' => $line,
                    'after' => $newLine
                ];

                // Add to file manifest
                $fileManifest['replacements'][] = [
                    'line' => $i + 1,
                    'before' => $line,
                    'after' => $newLine
                ];
            }
        }
    }

    // If the file was modified, write the changes back preserving original line endings
    if ($modified) {
        file_put_contents($filePath, implode($lineEnding, $lines));
    }

    // Add to manifest if there were any replacements or skipped lines
    if ($replacements > 0 || $skipped > 0) {
        $manifest[$filePath] = [
            'replacements' => $replacements,
            'skipped' => $skipped,
            'changes' => $fileManifest
        ];
    }

    return ['replacements' => $replacements, 'skipped' => $skipped];
}

// Function to write log to file
function writeLog($log, $logFile, $processedFiles, $totalFiles, $maxFilesToProcess = null) {
    $content = "# WordPress to WigglePuppy Batch Rebranding Log\n";
    $content .= "_This document was generated by JetBrains Junie_\n\n";
    $content .= "## Summary\n\n";
    if ($maxFilesToProcess !== null) {
        $content .= "- Files processed: $processedFiles out of $totalFiles available (limit: $maxFilesToProcess)\n";
    } else {
        $content .= "- Files processed: $processedFiles out of $totalFiles available (no limit applied)\n";
    }
    $content .= "- Files modified: " . count($log['files']) . "\n";
    $content .= "- Total replacements made: " . $log['totalReplacements'] . "\n";
    $content .= "- Total lines skipped due to caveats: " . $log['totalSkipped'] . "\n\n";

    $content .= "## Replacements\n\n";
    $content .= "| File | Line | Before | After |\n";
    $content .= "|------|------|--------|-------|\n";

    foreach ($log['replacements'] as $replacement) {
        $escapedBefore = str_replace('|', '\\|', $replacement['before']);
        $escapedAfter = str_replace('|', '\\|', $replacement['after']);
        $content .= "| {$replacement['file']} | {$replacement['line']} | `$escapedBefore` | `$escapedAfter` |\n";
    }

    // Add section for skipped lines
    $content .= "\n## Lines Skipped Due to Caveats\n\n";
    $content .= "| File | Line | Content | Reason |\n";
    $content .= "|------|------|---------|--------|\n";

    foreach ($log['skipped'] as $skipped) {
        $escapedContent = str_replace('|', '\\|', $skipped['content']);
        $content .= "| {$skipped['file']} | {$skipped['line']} | `$escapedContent` | {$skipped['reason']} |\n";
    }

    file_put_contents($logFile, $content);
}

// Function to write manifest to file
function writeManifest($manifest, $manifestFile) {
    file_put_contents($manifestFile, json_encode($manifest, JSON_PRETTY_PRINT));
}

// Main execution
echo "Starting WordPress to WigglePuppy batch rebranding...\n";

// Parse .gitignore file
echo "Parsing .gitignore file...\n";
$gitignorePatterns = parseGitignore($rootDir);

// Parse rebrand-ignore.txt file
echo "Parsing rebrand-ignore.txt file...\n";
$rebrandIgnorePatterns = parseRebrandIgnore($rootDir);

// Scan all files with specified extensions
echo "Scanning files...\n";
$files = scanDirectory($rootDir, $extensions, $gitignorePatterns, $rebrandIgnorePatterns, $rootDir);
echo "Found " . count($files) . " files to process.\n";

// Initialize log and manifest
$log = [
    'files' => [],
    'replacements' => [],
    'skipped' => [],
    'totalReplacements' => 0,
    'totalSkipped' => 0
];
$manifest = [];

// Process each file
$processedFiles = 0;
$totalFiles = count($files);
foreach ($files as $file) {
    // Stop after processing the maximum number of files if a limit is set
    if ($maxFilesToProcess !== null && $processedFiles >= $maxFilesToProcess) {
        echo "Reached limit of $maxFilesToProcess files. Stopping processing.\n";
        break;
    }

    $result = processFile($file, $skipPatterns, $replacementPatterns, $log, $manifest);
    $replacements = $result['replacements'];
    $skipped = $result['skipped'];

    if ($replacements > 0) {
        $log['files'][] = $file;
        $log['totalReplacements'] += $replacements;
    }

    if ($skipped > 0) {
        $log['totalSkipped'] += $skipped;
    }

    $processedFiles++;
    if ($processedFiles % 100 === 0 || $processedFiles === $totalFiles) {
        echo "Processed $processedFiles/$totalFiles files...\n";
    }
}

// Write log and manifest to files
echo "Writing log to $logFile...\n";
writeLog($log, $logFile, $processedFiles, $totalFiles, $maxFilesToProcess);

echo "Writing manifest to $manifestFile...\n";
writeManifest($manifest, $manifestFile);

echo "Batch rebranding complete!\n";
if ($maxFilesToProcess !== null) {
    echo "Files processed: $processedFiles out of $totalFiles available (limit: $maxFilesToProcess)\n";
} else {
    echo "Files processed: $processedFiles out of $totalFiles available (no limit applied)\n";
}
echo "Total files modified: " . count($log['files']) . "\n";
echo "Total replacements made: " . $log['totalReplacements'] . "\n";
echo "Total lines skipped due to caveats: " . $log['totalSkipped'] . "\n";
echo "Log file: $logFile\n";
echo "Manifest file: $manifestFile\n";
