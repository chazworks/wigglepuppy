<?php
/**
 * WordPress to WigglePuppy Rebranding Replacement Script
 *
 * This script performs regex-based replacements of "WordPress" with "WigglePuppy"
 * in non-PHP files (JS, HTML, CSS, etc.), following the caveats specified in the
 * rebranding plan.
 *
 * _This document was generated by JetBrains Junie_
 */

// Configuration
$extensions = ['js', 'html', 'css', 'txt', 'md', 'xml', 'json'];
$rootDir = dirname(dirname(__DIR__));
$outputDir = $rootDir . '/docs/rebranding';
$logFile = $outputDir . '/rebranding-replace-log.md';

// Regular expressions for identifying patterns that should not be replaced
$skipPatterns = [
    // Copyright notices and author attributions
    '/copyright.*wordpress|author.*wordpress/i',

    // Variable names
    '/\$[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*/i',

    // Function names
    '/function\s+[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*|[a-zA-Z0-9_]*wordpress[a-zA-Z0-9_]*\s*\(/i',

    // Filenames and paths
    '/[\'"][a-zA-Z0-9_\/\.\-]*wordpress[a-zA-Z0-9_\/\.\-]*[\'"]/i',

    // URLs
    '/https?:\/\/[a-zA-Z0-9_\.\-]*wordpress[a-zA-Z0-9_\.\-]*/i',

    // Organization references
    '/wordpress\s+team|wordpress\s+foundation|wordpress\s+community|by\s+wordpress/i',

    // Co-occurrence of WordPress and WigglePuppy
    '/.*wordpress.*wigglepuppy.*|.*wigglepuppy.*wordpress.*/i'
];

// Replacement patterns (preserving case)
$replacementPatterns = [
    '/\bWordPress\b/' => 'WigglePuppy',
    '/\bwordpress\b/' => 'wigglepuppy',
    '/\bWORDPRESS\b/' => 'WIGGLEPUPPY'
];

// Function to parse an ignore file and get patterns to exclude
function parseIgnoreFile($filePath) {
    if (!file_exists($filePath)) {
        return [];
    }

    $patterns = [];
    $lines = file($filePath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);

    foreach ($lines as $line) {
        // Skip comments and empty lines
        if (empty($line) || $line[0] === '#') {
            continue;
        }

        // Handle negated patterns (those starting with !)
        $isNegated = false;
        if ($line[0] === '!') {
            $isNegated = true;
            $line = substr($line, 1);
        }

        // Convert pattern to regex pattern
        $pattern = preg_quote($line, '/');
        $pattern = str_replace('\*', '.*', $pattern);

        // Handle directory patterns (those ending with /)
        if (substr($pattern, -1) === '/') {
            $pattern = $pattern . '.*';
        }

        // Add pattern to list
        $patterns[] = [
            'pattern' => '/^' . $pattern . '/',
            'negated' => $isNegated
        ];
    }

    return $patterns;
}

// Function to parse .gitignore file and get patterns to exclude
function parseGitignore($rootDir) {
    $gitignorePath = $rootDir . '/.gitignore';
    return parseIgnoreFile($gitignorePath);
}

// Function to parse rebrand-ignore.txt file and get patterns to exclude
function parseRebrandIgnore($rootDir) {
    $rebrandIgnorePath = $rootDir . '/tools/rebranding/rebrand-ignore.txt';
    return parseIgnoreFile($rebrandIgnorePath);
}

// Function to check if a file should be excluded based on .gitignore and rebrand-ignore.txt patterns
function shouldExcludeFile($filePath, $gitignorePatterns, $rebrandIgnorePatterns, $rootDir) {
    // Get relative path from root directory
    $relativePath = str_replace($rootDir . '/', '', $filePath);

    // Check if file matches any .gitignore pattern
    $excluded = false;
    foreach ($gitignorePatterns as $pattern) {
        if (preg_match($pattern['pattern'], $relativePath)) {
            $excluded = $pattern['negated'] ? false : true;
        }
    }

    // If not excluded by gitignore, check rebrand-ignore.txt patterns
    if (!$excluded) {
        foreach ($rebrandIgnorePatterns as $pattern) {
            if (preg_match($pattern['pattern'], $relativePath)) {
                $excluded = $pattern['negated'] ? false : true;
            }
        }
    }

    return $excluded;
}

// Function to scan directory using a non-recursive approach
function scanDirectory($dir, $extensions, $gitignorePatterns, $rebrandIgnorePatterns, $rootDir) {
    $results = [];
    $stack = [$dir];

    while (!empty($stack)) {
        $currentDir = array_pop($stack);
        $files = scandir($currentDir);

        foreach ($files as $file) {
            if ($file === '.' || $file === '..' || $file === '.git') {
                continue;
            }

            $path = $currentDir . '/' . $file;

            // Skip files/directories that match .gitignore or rebrand-ignore.txt patterns
            if (shouldExcludeFile($path, $gitignorePatterns, $rebrandIgnorePatterns, $rootDir)) {
                continue;
            }

            if (is_dir($path)) {
                // Add directory to stack for later processing
                $stack[] = $path;
            } else {
                $ext = pathinfo($path, PATHINFO_EXTENSION);
                if (in_array($ext, $extensions)) {
                    $results[] = $path;
                }
            }
        }
    }

    return $results;
}

// Function to check if a line should be skipped
function shouldSkipLine($line, $skipPatterns) {
    foreach ($skipPatterns as $pattern) {
        if (preg_match($pattern, $line)) {
            return true;
        }
    }
    return false;
}

// Function to replace WordPress with WigglePuppy in a line
function replaceWordPress($line, $replacementPatterns) {
    $newLine = $line;
    foreach ($replacementPatterns as $pattern => $replacement) {
        $newLine = preg_replace($pattern, $replacement, $newLine);
    }
    return $newLine;
}

// Function to process a file
function processFile($filePath, $skipPatterns, $replacementPatterns, &$log) {
    // Read the file content preserving the original line endings
    $content = file_get_contents($filePath);

    // Detect line endings (CR, LF, or CRLF)
    $lineEnding = "\n"; // Default to LF
    if (strpos($content, "\r\n") !== false) {
        $lineEnding = "\r\n"; // CRLF (Windows)
    } elseif (strpos($content, "\r") !== false) {
        $lineEnding = "\r"; // CR (old Mac)
    }

    $lines = explode($lineEnding, $content);
    $modified = false;
    $replacements = 0;

    foreach ($lines as $i => $line) {
        // Skip empty lines
        if (trim($line) === '') {
            continue;
        }

        // Skip lines that match skip patterns
        if (shouldSkipLine($line, $skipPatterns)) {
            continue;
        }

        // Replace WordPress with WigglePuppy while preserving whitespace
        $newLine = replaceWordPress($line, $replacementPatterns);

        // If the line was changed, update it
        if ($newLine !== $line) {
            $lines[$i] = $newLine;
            $modified = true;
            $replacements++;

            // Log the replacement
            $log[] = [
                'file' => $filePath,
                'line' => $i + 1,
                'before' => $line,
                'after' => $newLine
            ];
        }
    }

    // If the file was modified, write the changes back preserving original line endings
    if ($modified) {
        file_put_contents($filePath, implode($lineEnding, $lines));
        return $replacements;
    }

    return 0;
}

// Function to write log to file
function writeLog($log, $logFile) {
    $content = "# WordPress to WigglePuppy Replacement Log\n";
    $content .= "_This document was generated by JetBrains Junie_\n\n";
    $content .= "## Summary\n\n";
    $content .= "- Total files processed: " . count($log['files']) . "\n";
    $content .= "- Total replacements made: " . $log['totalReplacements'] . "\n\n";

    $content .= "## Replacements\n\n";
    $content .= "| File | Line | Before | After |\n";
    $content .= "|------|------|--------|-------|\n";

    foreach ($log['replacements'] as $replacement) {
        $escapedBefore = str_replace('|', '\\|', $replacement['before']);
        $escapedAfter = str_replace('|', '\\|', $replacement['after']);
        $content .= "| {$replacement['file']} | {$replacement['line']} | `$escapedBefore` | `$escapedAfter` |\n";
    }

    file_put_contents($logFile, $content);
}

// Main execution
echo "Starting WordPress to WigglePuppy rebranding replacement...\n";

// Parse .gitignore file
echo "Parsing .gitignore file...\n";
$gitignorePatterns = parseGitignore($rootDir);

// Parse rebrand-ignore.txt file
echo "Parsing rebrand-ignore.txt file...\n";
$rebrandIgnorePatterns = parseRebrandIgnore($rootDir);

// Scan all files with specified extensions
echo "Scanning files...\n";
$files = scanDirectory($rootDir, $extensions, $gitignorePatterns, $rebrandIgnorePatterns, $rootDir);
echo "Found " . count($files) . " files with specified extensions.\n";

// Initialize log
$log = [
    'files' => [],
    'replacements' => [],
    'totalReplacements' => 0
];

// Process each file
$processedFiles = 0;
$totalFiles = count($files);
foreach ($files as $file) {
    $replacements = processFile($file, $skipPatterns, $replacementPatterns, $log['replacements']);

    if ($replacements > 0) {
        $log['files'][] = $file;
        $log['totalReplacements'] += $replacements;
    }

    $processedFiles++;
    if ($processedFiles % 100 === 0 || $processedFiles === $totalFiles) {
        echo "Processed $processedFiles/$totalFiles files...\n";
    }
}

// Write log to file
echo "Writing log to $logFile...\n";
writeLog($log, $logFile);

echo "Rebranding replacement complete!\n";
echo "Total files modified: " . count($log['files']) . "\n";
echo "Total replacements made: " . $log['totalReplacements'] . "\n";
echo "Log file: $logFile\n";
