# WordPress Codebase Modernization Plan Using Rector
_This document was generated by Jetbrains Junie_

## Introduction

This document outlines a comprehensive plan to use Rector, a PHP code refactoring tool, to modernize the WordPress codebase. Rector can automatically upgrade PHP code to newer language features, apply best practices, and fix deprecated code patterns. This plan includes installation steps, configuration guidance, analysis of appropriate rules, and a strategy for implementing custom rules.

**Important Note on Backward Compatibility**: The requirement for backward compatibility applies only to the public WordPress API as used by plugins and themes, not to older versions of PHP itself. The implementations are allowed to require PHP 8.4+ features as long as the API stays compatible. This significantly changes our approach to modernization, allowing us to use modern PHP features internally while maintaining a stable external API.

## Installation and Configuration

### Installation Steps

1. Add Rector as a development dependency:
   ```bash
   composer require --dev rector/rector
   ```

2. Create a basic configuration file:
   ```bash
   vendor/bin/rector init
   ```

3. Configure PHP version constraints in `rector.php`:
   ```php
   use Rector\Config\RectorConfig;
   use Rector\Set\ValueObject\SetList;

   return function (RectorConfig $rectorConfig): void {
       // Define paths to refactor
       $rectorConfig->paths([
           __DIR__ . '/src'
       ]);

       // Skip certain paths
       $rectorConfig->skip([
           __DIR__ . '/src/wp-includes/ID3',
           __DIR__ . '/src/wp-includes/IXR',
           __DIR__ . '/src/wp-includes/PHPMailer',
           __DIR__ . '/src/wp-includes/Requests',
           __DIR__ . '/src/wp-includes/SimplePie',
           __DIR__ . '/src/wp-includes/sodium_compat',
           __DIR__ . '/src/wp-includes/Text',
           // Add other third-party libraries to skip
       ]);

       // Set PHP version - We can target PHP 8.4+ for internal implementation
       // while maintaining API compatibility for plugins and themes
       $rectorConfig->phpVersion(PhpVersion::PHP_84);
   };
   ```

4. Create a CI integration script in `bin/rector-check.sh`:
   ```bash
   #!/bin/bash
   vendor/bin/rector process --dry-run
   ```

5. Add a Composer script for convenience:
   ```json
   {
     "scripts": {
       "rector": "rector process",
       "rector:dry": "rector process --dry-run"
     }
   }
   ```

## Effective Rector Rules for WordPress

Rector rules for WordPress should be organized by risk level. The rules can be categorized into three groups:

1. **Low Risk Rules** - Rules that can be safely applied to the entire codebase
2. **Medium Risk Rules** - Rules that should be applied carefully, primarily to internal implementation code
3. **High Risk Rules** - Rules that should be applied with extreme caution, especially to public APIs

Each category should contain appropriate rules with documentation. The configuration should be set up to apply only low-risk rules by default, with options to enable medium and high-risk rules as needed.

### Sample Usage

```php
// Apply only low-risk rules (default)
$rectorConfig->rules([
    // List of low-risk rules
    SimplifyIfReturnBoolRector::class,
    // Add more low-risk rules here
]);

// Apply medium-risk rules to internal implementation code
$rectorConfig->rules([
    // List of medium-risk rules
    // Add medium-risk rules here
]);

// Apply high-risk rules after thorough analysis
$rectorConfig->rules([
    // List of high-risk rules
    // Add high-risk rules here
]);

// Apply multiple rule sets
$rectorConfig->rules([
    // Low-risk rules
    SimplifyIfReturnBoolRector::class,
    // Medium-risk rules
    // Add more rules here
]);
```

### Risk Considerations

- **Low Risk**: These rules improve code readability and maintainability without changing behavior. They include code quality improvements, dead code elimination, and coding style improvements.

- **Medium Risk**: These rules should be applied carefully, primarily to internal implementation code. They include PHP syntax upgrades, type declaration improvements, and naming convention standardization.

- **High Risk**: These rules should be applied with extreme caution, especially to public APIs. They include class structure changes, method signature changes, and architecture refactoring.

For detailed information about specific rules in each category, please refer to the sample configuration file.

## Relevant Third-Party Rector Rules

1. **PHPUnit Upgrades**
   ```php
   $rectorConfig->sets([SetList::PHPUNIT_90]);
   ```
   Useful for modernizing WordPress test suite.

2. **Symfony Rules**
   ```php
   // For WordPress components that use Symfony-like patterns
   $rectorConfig->sets([SetList::SYMFONY_50, SetList::SYMFONY_CODE_QUALITY]);
   ```

3. **[Mati456/rector-wordpress](https://github.com/Mati456/rector-wordpress)**
   A third-party package with WordPress-specific rules.

4. **[szepeviktor/phpstan-wordpress](https://github.com/szepeviktor/phpstan-wordpress)**
   While not Rector rules directly, this package provides WordPress-specific type information that can be useful when applying type-related Rector rules.

## Custom Rector Rules Organization

### Directory Structure

```
tools/
└── rector/
    ├── config/
    │   ├── sets/
    │   │   ├── wordpress-60.php
    │   │   ├── wordpress-61.php
    │   │   └── wordpress-custom.php
    │   └── wordpress-specific-rules.php
    ├── src/
    │   ├── Rector/
    │   │   ├── CodeQuality/
    │   │   ├── Deprecation/
    │   │   └── Security/
    │   └── Set/
    │       └── ValueObject/
    │           └── WordPressSetList.php
    └── tests/
        └── Rector/
            ├── CodeQuality/
            ├── Deprecation/
            └── Security/
```

### Implementation Strategy

1. **Create a Custom Rule Factory**

   ```php
   // tools/rector/src/WordPressRectorFactory.php
   namespace WordPress\Rector;

   use Rector\Config\RectorConfig;

   final class WordPressRectorFactory
   {
       public static function createWordPressConfig(RectorConfig $rectorConfig): void
       {
           // Apply WordPress-specific configuration
       }
   }
   ```

2. **Develop Custom Rules for WordPress-Specific Patterns**

   Example custom rule:
   ```php
   // tools/rector/src/Rector/Deprecation/WpDeprecatedFunctionToReplacementRector.php
   namespace WordPress\Rector\Deprecation;

   use PhpParser\Node;
   use PhpParser\Node\Expr\FuncCall;
   use PhpParser\Node\Name;
   use Rector\Core\Rector\AbstractRector;
   use Symplify\RuleDocGenerator\ValueObject\RuleDefinition;

   final class WpDeprecatedFunctionToReplacementRector extends AbstractRector
   {
       private const DEPRECATED_FUNCTIONS = [
           'get_page' => 'get_post',
           'is_page_template' => 'is_page_template',
           // Add more deprecated functions with their replacements
       ];

       public function getRuleDefinition(): RuleDefinition
       {
           // Rule documentation
       }

       public function getNodeTypes(): array
       {
           return [FuncCall::class];
       }

       public function refactor(Node $node): ?Node
       {
           // Implementation
       }
   }
   ```

3. **Create Custom Rule Sets**

   ```php
   // tools/rector/config/sets/wordpress-60.php
   use Rector\Config\RectorConfig;
   use WordPress\Rector\Deprecation\WpDeprecatedFunctionToReplacementRector;

   return static function (RectorConfig $rectorConfig): void {
       $rectorConfig->rule(WpDeprecatedFunctionToReplacementRector::class);
       // Add more WordPress 6.0-specific rules
   };
   ```

4. **Integration with Main Rector Configuration**

   ```php
   // rector.php
   use Rector\Config\RectorConfig;
   use WordPress\Rector\WordPressRectorFactory;

   return function (RectorConfig $rectorConfig): void {
       // Basic configuration
       $rectorConfig->paths([__DIR__ . '/src']);

       // Load WordPress-specific configuration
       WordPressRectorFactory::createWordPressConfig($rectorConfig);

       // Include custom WordPress rule sets
       $rectorConfig->sets([
           __DIR__ . '/tools/rector/config/sets/wordpress-60.php',
       ]);
   };
   ```

5. **Testing Strategy for Custom Rules**

   - Create fixture files that represent before/after code samples
   - Implement PHPUnit tests for each custom rule
   - Integrate with WordPress CI pipeline

## Execution Strategy

1. **Phased Approach**
   - Phase 1: Identify and categorize code into "public API" and "internal implementation"
   - Phase 2: Apply all PHP 8.4+ compatible rules to internal implementation code
   - Phase 3: Apply low-risk rules to the entire codebase
   - Phase 4: Apply medium-risk rules to public APIs with appropriate deprecation notices
   - Phase 5: Apply high-risk rules to public APIs only where absolutely necessary and with thorough testing

2. **Continuous Integration**
   - Add Rector checks to CI pipeline in dry-run mode
   - Generate reports of potential changes
   - Review changes manually before applying

3. **Documentation**
   - Document all applied transformations
   - Update coding standards documentation
   - Provide migration guides for plugin developers

4. **Monitoring**
   - Monitor WordPress test suite for any regressions
   - Track plugin compatibility issues
   - Adjust rules based on feedback

## Conclusion

This plan provides a structured approach to modernizing the WordPress codebase using Rector. With the clarification that backward compatibility requirements only apply to the public WordPress API (used by plugins and themes) and not to older versions of PHP itself, we can be much more aggressive in modernizing the internal implementation code.

The key benefits of this approach include:

1. **Faster Modernization**: Internal implementation code can immediately benefit from PHP 8.4+ features, improving performance, security, and developer experience.
2. **Cleaner Architecture**: Modern PHP features like typed properties, union types, and attributes can lead to more maintainable code.
3. **Better Static Analysis**: Modern type declarations enable better static analysis and IDE support.
4. **Reduced Technical Debt**: Newer PHP features often provide more elegant solutions to common problems.

Implementation should still proceed with a clear distinction between public API and internal implementation code. The public API should maintain backward compatibility with existing plugins and themes, while internal implementation can leverage the full power of modern PHP.

This balanced approach allows WordPress to modernize its codebase while fulfilling its commitment to backward compatibility where it matters most - at the plugin and theme interface level.
